#!/usr/bin/env bash
set -euo pipefail

# Test up.sh — worktree management (excluding tmux/CC launch)
# Sources the actual up.sh with REPO_ROOT pre-set and launch_tmux stubbed.

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
UP_SH="$SCRIPT_DIR/up.sh"

passed=0
failed=0

run_test() {
  local name="$1"
  shift
  if "$@"; then
    echo "PASS: $name"
    passed=$((passed + 1))
  else
    echo "FAIL: $name"
    failed=$((failed + 1))
  fi
}

tmpdir="$(mktemp -d)"
trap 'rm -rf "$tmpdir"' EXIT

setup_repo() {
  local testdir="$1"
  mkdir -p "$testdir"

  local staging="$tmpdir/staging-$$-$RANDOM"
  (
    mkdir "$staging" && cd "$staging"
    git init -q
    git checkout -q -b main

    mkdir -p scripts
    cat > scripts/up.sh <<'EOF'
#!/usr/bin/env bash
echo "placeholder"
EOF
    chmod +x scripts/up.sh

    cat > .env.example <<'EOF'
GH_TOKEN=github_pat_real_token
EOF

    git add -A
    git commit -q -m "initial"
  )

  (
    cd "$testdir"
    git clone -q --bare "$staging" .bare
    echo "gitdir: ./.bare" > .git
    git config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
    git fetch -q origin

    git worktree add main main 2>/dev/null

    cat > .env <<'EOF'
GH_TOKEN=ghp_realtoken123
EOF
  )

  rm -rf "$staging"
}

# Source up.sh functions and run worktree management in a subshell.
# Stubs launch_tmux, check_prerequisites, check_env.
run_up() {
  local repo_root="$1"
  local count="$2"

  (
    # Pre-set variables before sourcing up.sh
    export REPO_ROOT="$repo_root"
    export CONFIG_FILE="$repo_root/.up_config"
    export SESSION_NAME="ciya-test-$$"

    # Source the actual up.sh (BASH_SOURCE guard prevents main from running)
    source "$UP_SH"

    # Stub functions we can't run in tests
    launch_tmux() { :; }
    check_prerequisites() { :; }
    check_env() { :; }
    load_env() { :; }

    cd "$REPO_ROOT"
    local c
    c="$(get_worker_count "$count")"
    ensure_main_worktree
    ensure_work_worktrees "$c"
    remove_excess_worktrees "$c"
    echo "$c" > "$CONFIG_FILE"
  )
}

# --- Test 1: up.sh 4 creates work-1 through work-4 ---
test_creates_4_worktrees() {
  # Given: a fresh bare repo
  local testdir="$tmpdir/test1"
  setup_repo "$testdir"
  # When: running up.sh with count 4
  run_up "$testdir" 4
  # Then: work-1 through work-4 exist, work-5 does not
  [ -d "$testdir/work-1" ] &&
  [ -d "$testdir/work-2" ] &&
  [ -d "$testdir/work-3" ] &&
  [ -d "$testdir/work-4" ] &&
  [ ! -d "$testdir/work-5" ]
}
run_test "up.sh 4 creates work-1 through work-4" test_creates_4_worktrees

# --- Test 2: Config file stores worker count ---
test_stores_config() {
  # Given: test1 repo after running up.sh 4 (from test 1)
  # When + Then: config file contains 4
  [ -f "$tmpdir/test1/.up_config" ] &&
  [ "$(cat "$tmpdir/test1/.up_config")" = "4" ]
}
run_test "Config file stores worker count" test_stores_config

# --- Test 3: up.sh 6 adds work-5 and work-6 ---
test_adds_worktrees() {
  # Given: test1 repo already has work-1 through work-4
  # When: running up.sh with count 6
  run_up "$tmpdir/test1" 6
  # Then: work-5 and work-6 are added
  [ -d "$tmpdir/test1/work-5" ] &&
  [ -d "$tmpdir/test1/work-6" ] &&
  [ ! -d "$tmpdir/test1/work-7" ]
}
run_test "up.sh 6 adds work-5 and work-6" test_adds_worktrees

# --- Test 4: up.sh 2 removes work-3 through work-6 ---
test_removes_worktrees() {
  # Given: test1 repo has work-1 through work-6
  # When: running up.sh with count 2
  run_up "$tmpdir/test1" 2
  # Then: work-3 through work-6 are removed, work-1 and work-2 remain
  [ -d "$tmpdir/test1/work-1" ] &&
  [ -d "$tmpdir/test1/work-2" ] &&
  [ ! -d "$tmpdir/test1/work-3" ] &&
  [ ! -d "$tmpdir/test1/work-4" ] &&
  [ ! -d "$tmpdir/test1/work-5" ] &&
  [ ! -d "$tmpdir/test1/work-6" ]
}
run_test "up.sh 2 removes work-3 through work-6" test_removes_worktrees

# --- Test 5: Dirty worktree prevents removal ---
test_dirty_prevents_removal() {
  # Given: a repo with 3 worktrees and an uncommitted file in work-2
  local testdir="$tmpdir/test5"
  setup_repo "$testdir"
  run_up "$testdir" 3
  echo "uncommitted" > "$testdir/work-2/dirty.txt"
  # When: trying to reduce to 1 worktree
  # Then: fails because work-2 is dirty
  ! run_up "$testdir" 1 2>/dev/null
}
run_test "Dirty worktree prevents removal" test_dirty_prevents_removal

# --- Test 6: Invalid argument rejected ---
test_invalid_arg() {
  ! (
    export REPO_ROOT="$tmpdir/test1"
    export CONFIG_FILE="$tmpdir/test1/.up_config"
    source "$UP_SH"
    get_worker_count "abc"
  ) 2>/dev/null &&
  ! (
    export REPO_ROOT="$tmpdir/test1"
    export CONFIG_FILE="$tmpdir/test1/.up_config"
    source "$UP_SH"
    get_worker_count "0"
  ) 2>/dev/null &&
  ! (
    export REPO_ROOT="$tmpdir/test1"
    export CONFIG_FILE="$tmpdir/test1/.up_config"
    source "$UP_SH"
    get_worker_count "-1"
  ) 2>/dev/null
}
run_test "Invalid argument rejected" test_invalid_arg

# --- Test 7: No config and no argument defaults to 1 ---
test_no_config_no_arg_defaults() {
  # Given: no config file and CIYA_WORK_COUNT unset
  local testdir="$tmpdir/test7"
  setup_repo "$testdir"
  local result
  [ ! -f "$testdir/.up_config" ] &&
  result="$(
    export REPO_ROOT="$testdir"
    export CONFIG_FILE="$testdir/.up_config"
    unset CIYA_WORK_COUNT
    source "$UP_SH"
    get_worker_count ""
  )" &&
  # Then: defaults to 1
  [ "$result" = "1" ]
}
run_test "No config and no argument defaults to 1" test_no_config_no_arg_defaults

# --- Test 8: Config created after successful run ---
test_config_after_run() {
  local testdir="$tmpdir/test7"
  run_up "$testdir" 2
  [ -f "$testdir/.up_config" ] &&
  [ "$(cat "$testdir/.up_config")" = "2" ]
}
run_test "Config created after successful run" test_config_after_run

# --- Test 9: CIYA_WORK_COUNT overrides default ---
test_ciya_work_count_override() {
  # Given: no config file and CIYA_WORK_COUNT=5
  local testdir="$tmpdir/test7"
  local result
  [ ! -f "$testdir/.up_config" ] || rm "$testdir/.up_config"
  result="$(
    export REPO_ROOT="$testdir"
    export CONFIG_FILE="$testdir/.up_config"
    export CIYA_WORK_COUNT=5
    source "$UP_SH"
    # When: get_worker_count with no argument
    get_worker_count ""
  )" &&
  # Then: uses CIYA_WORK_COUNT value
  [ "$result" = "5" ]
}
run_test "CIYA_WORK_COUNT overrides default" test_ciya_work_count_override

# ── check_prerequisites ───────────────────────────────────────
echo "check_prerequisites:"

# --- Test 10: All prerequisites present ---
test_prerequisites_all_present() {
  # Given: a PATH with all required commands
  local fake_bin="$tmpdir/fake_bin"
  mkdir -p "$fake_bin"
  for cmd in claude git tmux gh; do
    printf '#!/bin/sh\ntrue\n' > "$fake_bin/$cmd"
    chmod +x "$fake_bin/$cmd"
  done
  # When+Then: check_prerequisites succeeds
  (
    export REPO_ROOT="$tmpdir/test1"
    source "$UP_SH"
    PATH="$fake_bin"
    check_prerequisites
  )
}
run_test "All prerequisites present" test_prerequisites_all_present

# --- Test 11: Missing command detected ---
test_prerequisites_missing_command() {
  # Given: a PATH where gh is missing
  local fake_bin="$tmpdir/fake_bin_no_gh"
  mkdir -p "$fake_bin"
  for cmd in claude git tmux; do
    printf '#!/bin/sh\ntrue\n' > "$fake_bin/$cmd"
    chmod +x "$fake_bin/$cmd"
  done
  # When+Then: check_prerequisites exits non-zero
  ! (
    export REPO_ROOT="$tmpdir/test1"
    source "$UP_SH"
    PATH="$fake_bin"
    check_prerequisites
  ) 2>/dev/null
}
run_test "Missing command detected" test_prerequisites_missing_command

# --- Test 12: Error message lists missing command names ---
test_prerequisites_error_message() {
  # Given: a PATH where tmux and gh are missing
  local fake_bin="$tmpdir/fake_bin_partial"
  mkdir -p "$fake_bin"
  for cmd in claude git; do
    printf '#!/bin/sh\ntrue\n' > "$fake_bin/$cmd"
    chmod +x "$fake_bin/$cmd"
  done
  # When: running check_prerequisites
  local output
  output="$(
    export REPO_ROOT="$tmpdir/test1"
    source "$UP_SH"
    PATH="$fake_bin"
    check_prerequisites 2>&1
  )" || true
  # Then: error message includes both missing command names
  [[ "$output" == *"tmux"* ]] && [[ "$output" == *"gh"* ]]
}
run_test "Error message lists missing command names" test_prerequisites_error_message

# ── ensure_kcov ───────────────────────────────────────────────
echo "ensure_kcov:"

# --- Test 13: ensure_kcov skips when kcov is already installed ---
test_ensure_kcov_skips_when_installed() {
  # Given: a PATH with kcov available
  local fake_bin="$tmpdir/fake_bin_kcov"
  mkdir -p "$fake_bin"
  printf '#!/bin/sh\ntrue\n' > "$fake_bin/kcov"
  chmod +x "$fake_bin/kcov"
  # When+Then: ensure_kcov succeeds without calling sudo
  (
    export REPO_ROOT="$tmpdir/test1"
    source "$UP_SH"
    PATH="$fake_bin"
    ensure_kcov
  )
}
run_test "ensure_kcov skips when kcov is already installed" test_ensure_kcov_skips_when_installed

# --- Results ---
echo ""
echo "Results: $passed passed, $failed failed"
[ "$failed" -eq 0 ]
